<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=description content="
        
      "><meta name=keywords content="version,control,,Git,,branching,,GitFlow,,trunk-based"><meta name=generator content="Hugo 0.117.0"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel="alternate stylesheet" href=/css/themes/atelier/cave.css title="Atelier Cave"><link rel="alternate stylesheet" href=/css/themes/atelier/dune.css title="Atelier Dune"><link rel="alternate stylesheet" href=/css/themes/atelier/estuary.css title="Atelier Estuary"><link rel="alternate stylesheet" href=/css/themes/atelier/forest.css title="Atelier Forest"><link rel="alternate stylesheet" href=/css/themes/atelier/heath.css title="Atelier Heath"><link rel="alternate stylesheet" href=/css/themes/atelier/lakeside.css title="Atelier Lakeside"><link rel="alternate stylesheet" href=/css/themes/atelier/plateau.css title="Atelier Plateau"><link rel="alternate stylesheet" href=/css/themes/atelier/savanna.css title="Atelier Savanna"><link rel="alternate stylesheet" href=/css/themes/atelier/seaside.css title="Atelier Seaside"><link rel="alternate stylesheet" href=/css/themes/atelier/sulphurpool.css title="Atelier Sulphurpool"><link rel="alternate stylesheet" href=/css/themes/atlas.css title=Atlas><link rel="alternate stylesheet" href=/css/themes/base16/cupcake.css title="Base16 Cupcake"><link rel="alternate stylesheet" href=/css/themes/base16/default.css title="Base16 Default"><link rel="alternate stylesheet" href=/css/themes/base16/eighties.css title="Base16 Eighties"><link rel="alternate stylesheet" href=/css/themes/base16/mocha.css title="Base16 Mocha"><link rel="alternate stylesheet" href=/css/themes/base16/ocean.css title="Base16 Ocean"><link rel=stylesheet href=/css/themes/solarized.css title=Solarized><link rel=alternate href=/index.xml type=application/rss+xml title=similitude><link rel=openid.server href=https://id.sim.ilitu.de/><link rel=openid2.provider href=https://id.sim.ilitu.de/><link rel=me href=https://indieweb.social/@smnscp><link rel=me href=https://github.com/smnscp><link rel=webmention href=https://webmention.io/sim.ilitu.de/webmention><link rel=pingback href=https://webmention.io/sim.ilitu.de/xmlrpc><title>The Most Natural Branching Model | similitude</title></head><body class=lyo-page-center><header><section><p><a href=https://sim.ilitu.de/ class=clr-prism-2>similitude</a></p><fieldset class=var-theme-switch><label for=scheme-switch>‚òæ</label>
<input type=range name=scheme-switch min=0 max=1 value=0 step=1 data-behavior=scheme-switch>
<label for=scheme-switch>‚òº</label></fieldset><fieldset class=var-theme-switch><label for=theme-switch>‚ùÆ</label>
<input type=range name=theme-switch min=0 max=-1 value=0 step=1 data-behavior=theme-switch style=inline-size:4rem>
<label for=theme-switch>‚ùØ</label></fieldset><script src=/js/theme-switch.js defer></script><nav><menu><li><a href=/pages/about/>About</a></li></menu></nav></section></header><main><article class=var-single-article itemscope itemtype=http://schema.org/BlogPosting><dl class=var-meta><dt>published on</dt><dd><time itemprop=datePublished datetime=2023-03-08>March 08, 2023</time></dd><dt>sorted in</dt><dd><a href=/categories/code>code</a></dd></dl><h1 itemprop=headline>The Most Natural Branching Model</h1><section class=body itemprop=articleBody><p>This is about an argument I‚Äôve had several times in my professional life as a software developer. To my mind the topic is pretty basic, <em>no</em> <i>rocket science</i> at all<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. It‚Äôs about <a href=https://en.wikipedia.org/wiki/Branching_(version_control)>branching in version control</a>. And there‚Äôs plenty of articles and documentation out there discussing that basic topic and describing best practices.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> So, I won‚Äôt make any claim that I could add essential new thoughts to it. But since that discussion keeps popping up every now and then I‚Äôll write down my take on it and some observations and learnings just for later reference. And also because many of the results of a web search for <i>‚Äúbest branching strategy‚Äù</i><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> are nothing but marketing filling material articles that try to be all too neutral or just mirror some ideas collected from their own web search. In their superficiality I haven‚Äôt found them helpful for decision making in a team. In contrast, this one‚Äôs gonna be opinionated and based on my own experience and learnings from the past decade.</p><p><strong>TL;DR:</strong> <i>GitFlow</i>, though having gained notable popularity, came with substantial design flaws, but at least it mad<a href=https://youtu.be/_w6TwnLCFwA></a>e people come up with names for the nothing new but most natural branching model: <i>The Cactus Model</i> or <i>Trunk-based Development</i>.</p><h2 id=who-needs-parallel-history>Who needs parallel history?</h2><p>So, you have heard about <i>GitFlow</i>. Sure, you have. It was very popular about ten years ago. And that was probably because it was very well thought-through and documented, really nicely presented in <a href=https://nvie.com/posts/a-successful-git-branching-model/>a well-written article</a>, and first and foremost, it came with a set of clear rules. And people long for clear rules, especially tech people like us, don‚Äôt we? So, before I go into any criticism, I want to make clear that I really appreciate that model having been shared with the community. Making our ideas a common good instead of keeping them enclosed in the silos of our brains makes us move forward and grow together.</p><p>Anyway, here‚Äôs my bold statement: <b title="I‚Äôm a <b> element used for boldness. Not quite appropriate but funny, isn‚Äôt it?">Alternate-history branches are bad üò±.</b> If your branching model involves two or more permanent branches meant to be <em>merged back and forth</em><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> think twice whether it‚Äôs really worth the hassle.</p><p>Okay, it‚Äôs not like this kind of branching and merging is bad in the sense of killing kittens or inevitably ruining your team‚Äôs productivity. It‚Äôs just that it‚Äôs extra complexity added to your version control. And tech people like us want extra complexity to be be well-founded or avoided, don‚Äôt we? So, before settling on GitFlow or some derivative you should really ask yourself why you would want multiple branches telling parallel, divergent versions of code history<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>? At long sight, the only timeline that matters is the one documenting <strong>what changes</strong> were made to the <strong>main branch</strong> in <strong>which order</strong>.</p><h2 id=why-complex-branching-doesnt-make-sense>Why complex branching doesn‚Äôt make sense</h2><p>Now, before I go ahead and talk about the obvious alternative I want to point out what appear to be the core assumptions that led to the belief that multiple parallel branches are a good idea.</p><h3 id=branching--deployment>Branching ‚â† Deployment</h3><p>I often hear developers argue for two parallel branches because they want one for each <a href=https://en.wikipedia.org/wiki/Deployment_environment>deployment environment</a>. The underlying common misconception seems to be that automated <a href=https://en.wikipedia.org/wiki/Continuous_deployment>continuous deployment</a> can only happen from a <em>permanent</em> branch that perfectly <em>mirrors</em> the deployment history. That‚Äôs not true.</p><p>To deploy a version-controlled codebase, essentially, you need a way to specify the commit that you intend to deploy at any time. While the most immediate way would be to just pass the respective commit hash to some deployment command, you‚Äôll probably don‚Äôt want that as it doesn‚Äôt allow for automatic deployments triggered by plain commit events. What you‚Äôd rather want is some symbolic name on your version control that your CD can watch for. This is where branches come in handy, because <a href=https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/#branches-are-pointers>branches are nothing but symbolic names for commits</a>. Yes, it‚Äôs perfectly fine to rely on branches to point to the respective commits for your automatic deployments. But apart from acting as named pointers there‚Äôs nothing that branches do for you with regards to automatic deployment. Especially, there is no use in mirroring deployment history.<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></p><h3 id=no-urge-to-merge>No urge to merge</h3><p>A common companion to the idea of having parallel branches to tell certain kinds of history is that those branches from time to time have to be <a href=https://nvie.com/posts/a-successful-git-branching-model/#the-main-branches>‚Äúsynchronized‚Äù by merging them</a>. And not only those permanent ones but also all kinds of side branches, like <a href=https://nvie.com/posts/a-successful-git-branching-model/#incorporating-a-finished-feature-on-develop>feature branches</a>, <a href=https://nvie.com/posts/a-successful-git-branching-model/#finishing-a-release-branch>release branches</a>, or <a href=https://nvie.com/posts/a-successful-git-branching-model/#finishing-a-hotfix-branch>hotfix branches</a>.</p><p>While it‚Äôs obvious why you want to keep side branches up to date with the main branch, it‚Äôs quite questionable why <em>everything</em> happening on some side branch should need to go back into the main branch, even including the history of that side branch. My take on this is to be really relaxed about side branches and their history and only care about the main branch. As I said above this is where all relevant code history is written, whereas side branches only exist for one single temporary purpose and hence, are perfectly fine to stay open-ended or even be cut out, eventually. However, there should never the need arise to <a href=https://book.git-scm.com/docs/gitglossary#def_merge>merge</a> (as in, non fast-forward merge) them back into the main branch. Let‚Äôs prove this for the three common types of side branches mentioned above:</p><dl><dt>Feature branch</dt><dd>This is a branch owned by one developer (or small team) working on a specific feature. Its main purpose is to be able to implement that feature without getting distracted by concurrent changes to the codebase and without having to commit intermediary states to the the main branch. Only when the feature is ready all its related code changes go to the main branch at once. At that moment it doesn‚Äôt really matter<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup> when and on which base the original commits were made. If our goal is to keep the history free from irrelevant information then the cleanest way of merging a feature branch to the main branch is <a href=https://book.git-scm.com/docs/gitglossary#def_rebase>rebasing</a> the latter onto the former and <a href=https://book.git-scm.com/docs/gitglossary#def_fast_forward>fast-forwarding</a> the former to the rebased head (a. k. a. ‚Äúrebase-merge‚Äù).<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup></dd><dt>Release branch</dt><dd>This branch is meant to point to a commit to be deployed to a given target or released as a package at a well-defined version. It‚Äôs not meant to receive any active development. The only changes that are acceptable as well as expectable on release branches are hotfixes. And those do not need to be merged back to the main branch. Instead they should be applied there <em>independently</em>. There are <a href=https://trunkbaseddevelopment.com/branch-for-release/#fix-production-bugs-on-trunk>some best practices</a> regarding a well-defined procedure for applying hotfixes by <a href=https://book.git-scm.com/docs/gitglossary#def_cherry-picking>cherry-picking</a>. But the important idea is that the main and the release branch are fixed by different commits (<a href=https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/#if-commits-arent-diffs-then-what-does-git-cherry-pick-do>cherry-picks are actually less special</a> than many people think).</dd><dt>Hotfix branch</dt><dd>This is either branched off of the main branch and then used for ‚Äúa hotfix release‚Äù, making it effectively just a special case of release branch. Or it‚Äôs branched off of a release branch to work on a hotfix and then merge it back to that release branch. It all boils down to making hotfix commits to releases. Therefore the above also applies to this kind of side branch.</dd></dl><h2 id=keep-it-linear-lovely>Keep It Linear, Lovely!</h2><p>It might not always be true, but in this case <abbr title="Keep It Linear, Lovely!">K.I.L.L.</abbr><sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup> is a special case of <a href=https://en.wikipedia.org/wiki/KISS_principle><abbr title="Keep It Simple, Stupid!">K.I.S.S.</abbr></a>. As I pointed out above complex branching models are oftentimes less helpful than they were supposed to be. Instead, in most common cases it‚Äôs perfectly sufficient to stick with a much simpler branching model with just one main branch and only temporary side branches. While <a href=https://trunkbaseddevelopment.com/#history>this idea has been nothing special for several decades</a> it became the recommended alternative to GitFlow when people realized that the latter is rather getting in their way. It has since been referred to as <i>Trunk-based Development</i> with <a href=https://trunkbaseddevelopment.com/>trunkbaseddevelopment.com</a> having become the go-to information source.</p><p>I just love it for its simplicity and its similarity to nature<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>. Instead of having <a href=https://stackoverflow.com/questions/14023648/why-does-my-git-history-look-like-a-christmas-tree>a Git graph full of merge commits</a> we can just let it grow like a natural tree with one trunk and several branches that grow from it but never back.<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Darn it! I‚Äôll probably never write about rocket science.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Sources I recommend:</p><ul><li>the <a href=https://nvie.com/posts/a-successful-git-branching-model/>article introducing GitFlow</a></li><li>an early <a href=https://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/>article criticizing GitFlow</a></li><li>a popular <a href=https://trunkbaseddevelopment.com/>documentation portal on Trunk-based Development</a></li><li>Dave Farley explaining <a href=https://youtu.be/_w6TwnLCFwA>why GitFlow is a bad idea</a></li></ul>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li><li id=fn:3><p>Well, search strings starting with ‚Äúbest‚Äù are prone to bring up pretentious results, aren‚Äôt they?&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>The coupling of the two branches is important here. My criticism does not apply to multiple permanent branches that are disjunct by design. Situations where, for example, several diverged versions of a product are maintained on corresponding branches are a different kettle of fish. And so are peculiar branches dedicated to special features of a repository, e. g. <i>gh-pages</i>.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>I‚Äôm a huge fan of science fiction which implies a fascination of time traveling and alternative timelines. I also like the <a href=https://en.wikipedia.org/wiki/Many-worlds_interpretation>many-worlds interpretation</a> just for its story-telling potential. But when it comes to writing and, even more, reading code I do not seek exciting stories to be told: I want it clean, dry, sober ‚Äì in all dimensions, including the temporal one.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>I‚Äôve heard people argue that they want to see the history of commits as they have been deployed. Well, first of all, code history is actually <a href=https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/#commits-are-snapshots>linked in the commit</a> itself, not <a href=https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/#branches-are-pointers>in a branch</a>. Second, code history matters at development time, not at deployment time where the code state of interest is in the one of the given commit, not any of its anccestor commits. But the main point here is that deployment history and code history are two distinct things. Why bloat your version control with branches that only exist to tell deployment history? Instead, just maintain a log of commit hashes and deploy timestamps outside of your version control (somewhere connected to your deployment target) and you have exactly what you need and keep different sets of information separated and where they belong.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>Maybe it does matter to the commits‚Äô author for some nostalgic reason, but to the whole team or other consumers of the code history (e. g. the public) it doesn‚Äôt.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>How you actually merge your feature branch remains of course a <a href=https://trunkbaseddevelopment.com/short-lived-feature-branches/#personal-preferences>matter of taste</a>. You might be convinced of the <a href=https://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/#there-are-only-fast-forward-merges>fast-forward-only approach</a>. But you might as well <a href=https://nvie.com/posts/a-successful-git-branching-model/#incorporating-a-finished-feature-on-develop>insist in keeping feature development details by enforcing merge commits</a>. Beware, though, that merge commits are not the only way to preserve those details: Even after <a href=https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#squash-and-merge-your-commits>squash-merging a pull request</a> and <a href=https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-branches-in-your-repository/deleting-and-restoring-branches-in-a-pull-request#deleting-a-branch-used-for-a-pull-request>deleting the feature branch</a> the <a href=https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-branches-in-your-repository/deleting-and-restoring-branches-in-a-pull-request#restoring-a-deleted-branch>original commits remain accessible</a> (depending on some platform features).&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>I think, I invented it. üò§&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p>Although, I know that <a href=https://en.wikipedia.org/wiki/Appeal_to_nature>appeal to nature</a> is not a valid reasoning.&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11><p>Technically, merge commits or actually allowing the commit graph to be a <a href=https://en.wikipedia.org/wiki/Directed_acyclic_graph>DAG</a> rather than just a (directed) <a href=https://en.wikipedia.org/wiki/Tree_(graph_theory)>tree</a> is a great feature of Git. And there are valid use cases, for sure. But in many day-to-day situations merge commits are rather bloat to your history that could be prevented with a little care.&#160;<a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><section id=sec:webmentions></section><script src=https://cdn.jsdelivr.net/npm/webmention.js@0.5.2/static/webmention.min.js data-id=sec:webmentions data-wordcount=100 async></script><section id=sec:comments><h2>Comments</h2><sz-root src=https://comments.sim.ilitu.de/comments/the-most-natural-branching-model><noscript>JavaScript needed here.</noscript></sz-root></section><script type=module>
  import "https:\/\/comments.sim.ilitu.de/js/senfdazu/root_element.js";
  import BaseElement from "https:\/\/comments.sim.ilitu.de/js/simple/base_element.js";
  import md from "/js/md.js";

  const hlStyle = `<link rel="stylesheet" href="/css/hljs.css" />`;

  class MarkdownElement extends BaseElement {
    render(text) {
      this.innerHTML = md.render(text) + hlStyle;
    }
  }

  customElements.define("md-div", MarkdownElement);
</script></article></main><footer><section><p>¬© 2023 similitude</p></section></footer></body></html>